// This file is part of the Polymesh distribution (https://github.com/PolymathNetwork/Polymesh).
// Copyright (c) 2020 Polymath

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, version 3.

// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

// To make sure we are on the no_std when compiling to wasm
#![cfg_attr(not(feature = "std"), no_std)]

use codec::Encode;
use frame_support::{
    debug, decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult, ensure,
    traits::Get, weights::SimpleDispatchInfo, Parameter,
};
use frame_system::{self as system, ensure_none, offchain};
use sp_application_crypto::RuntimeAppPublic;
use sp_core::crypto::KeyTypeId;
use sp_runtime::traits::{Member, SaturatedConversion};
use sp_runtime::transaction_validity::{
    InvalidTransaction, TransactionPriority, TransactionValidity, ValidTransaction,
};
use sp_std::prelude::*;

#[cfg(test)]
mod mock;
#[cfg(test)]
mod tests;

/// Defines application identifier for crypto keys of this module.
///
/// Every module that deals with signatures needs to declare its unique identifier for
/// its crypto keys.
/// When offchain worker is signing transactions it's going to request keys of type
/// `KeyTypeId` from the keystore and use the ones it finds to sign the transaction.
/// The keys can be inserted manually via RPC (see `author_insertKey`).
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"cddw");

/// Based on the above `KeyTypeId` we need to generate a pallet-specific crypto type wrappers.
/// We can use from supported crypto kinds (`sr25519`, `ed25519` and `ecdsa`) and augment
/// the types with this pallet-specific identifier.
pub mod crypto {
    pub use super::KEY_TYPE;
    mod app_crypto_sr25519 {
        use super::KEY_TYPE;
        use sp_runtime::app_crypto::{app_crypto, sr25519};
        app_crypto!(sr25519, KEY_TYPE);
    }
    /// An cdd_offchain identifier using sr25519 as its crypto.
    pub type SignerId = app_crypto_sr25519::Public;
}

pub trait Trait: frame_system::Trait + pallet_staking::Trait {
    type SignerId: Member + Parameter + RuntimeAppPublic + Default + Ord;
    /// The overarching event type.
    type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
    /// The overarching dispatch call type
    type Call: From<Call<Self>>;
    /// No. of blocks delayed to execute the off-chain worker
    type CoolingInterval: Get<Self::BlockNumber>;
    /// Buffer given to check the validity of the cdd claim. It is in block numbers.
    type BufferInterval: Get<Self::BlockNumber>;
    /// The type to sign and submit transactions.
    type SubmitUnsignedTransaction: offchain::SubmitUnsignedTransaction<Self, <Self as Trait>::Call>;
}

decl_storage! {
    trait Store for Module<T: Trait> as CddOffchainWorker {
        /// Last block at which unsigned transaction get submitted with in the transaction pool
        pub LastExtSubmittedAt get(last_extrinsic_submitted_at): T::BlockNumber;
    }
}

decl_event! {
    /// Events generated by the module.
    pub enum Event<T>
        where
        BlockNumber = <T as frame_system::Trait>::BlockNumber,
        AccountId = <T as frame_system::Trait>::AccountId,
    {
        /// Event generated when nominators get removed from the `Staking` storage
        InvalidateNominators(BlockNumber, Vec<AccountId>),
    }
}

decl_module! {
    pub struct Module<T: Trait> for enum Call where origin: T::Origin {
        type Error = Error<T>;

        /// initialize the default event for this module
        fn deposit_event() = default;

        /// Submit the list of invalidate nominators via unsigned transaction.
        ///
        /// we allow sending the transaction without a signature, and hence without paying any fees,
        /// we need a way to make sure that only some transactions are accepted.
        /// This function can be called only once every `T::CoolingInterval` blocks.
        /// Transactions that call that function are de-duplicated on the pool level
        /// via `validate_unsigned` implementation and also are rendered invalid if
        /// the function has already been called in current "session".
        ///
        /// It's important to specify `weight` for unsigned calls as well, because even though
        /// they don't charge fees, we still don't want a single block to contain unlimited
        /// number of such transactions.
        #[weight = SimpleDispatchInfo::FixedOperational(10_000_000)]
        fn take_off_invalidate_nominators(origin, _block_number: T::BlockNumber, target: Vec<T::AccountId>, _signature: <T::SignerId as RuntimeAppPublic>::Signature) -> DispatchResult {
            // This is an unsigned transaction so origin should be none
            ensure_none(origin)?;
            // apply a sanity check to know whether the length of target list is greater than 0 or not.
            ensure!(target.len() > 0, Error::<T>::EmptyTargetList);
            // call the mutable function that will change the list of nominators in the staking pallet
            let _ = <pallet_staking::Module<T>>::unsafe_validate_cdd_expiry_nominators(target.clone())?;
            // now change the block number at which this unsigned transaction get executed.
            let current_block = <system::Module<T>>::block_number();
            <LastExtSubmittedAt<T>>::put(current_block);
            Self::deposit_event(RawEvent::InvalidateNominators(
                <frame_system::Module<T>>::block_number(),
                target,
            ));
            Ok(())
        }


        fn offchain_worker(block: T::BlockNumber) {
            // Print the debug statement to know that offchain worker initiated
            debug::native::info!("Hello World from offchain workers!");
            if Self::is_unsigned_transaction_allowed(block) {
                debug::native::info!("Yeah transaction is allowed!");
                // Fetch all the nominators whose cdd claim get expired or expiry remaining time is less
                // than the `BufferInterval`. List of the Vec<Stash> get retrieved from the staking module
                let invalid_nominators = <pallet_staking::Module<T>>::fetch_invalid_cdd_nominators((T::BufferInterval::get()).saturated_into::<u64>());
                debug::debug!("Invalid nominators are fetched from the staking pallet: {:?}", invalid_nominators);
                // Avoid calling unsigned transaction when invalid nominators length of `invalid_nominators` vector is 0.
                if invalid_nominators.len() > 0 {
                    debug::debug!("Length of the nominators is greater than 0: {:?}", invalid_nominators.len());
                    let res = Self::remove_invalidate_nominators(block, invalid_nominators);
                    if let Err(e) = res {
                        debug::error!("Error: {}", e);
                    }
                }
            }
        }
    }
}

decl_error! {
    pub enum Error for Module<T: Trait> {
        /// List of invalidate nominators is empty
        EmptyTargetList
    }
}

impl<T: Trait> Module<T> {
    fn remove_invalidate_nominators(
        block: T::BlockNumber,
        invalid_nominators: Vec<T::AccountId>,
    ) -> Result<(), &'static str> {
        debug::native::info!("Enter into remove invalidate nominators functions");
        use frame_system::offchain::SubmitUnsignedTransaction;
        // First we validate whether the transaction proposer is validator or not.
        // if yes then only the transaction get proposed otherwise not.
        ensure!(sp_io::offchain::is_validator(), "Not a validator");
        // Accessing the first key in the local store to sign the payload
        if let Some(key) = T::SignerId::all().into_iter().next() {
            let signature = key
                .sign(&invalid_nominators.encode())
                .ok_or("Keys are not present or not able to sign")?;
            // Retrieve value of invalidate nominators get passed to the `take_off_invalidate_nominators`
            // i.e a public dispatchable of this pallet. It will be used to remove all the
            // nominators whom cdd claim got expired. internally it called the staking pallet functionality.
            // Here we specify the function to be called back on-chain in next block import.
            let call =
                Call::take_off_invalidate_nominators(block, invalid_nominators.clone(), signature);

            // Now let's create an unsigned transaction out of this call and submit it to the pool.
            // By default unsigned transactions are disallowed, so we need to exempt this case
            // by writing `UnsignedValidator`. Note that it's EXTREMELY important to carefully
            // implement unsigned validation logic, as any mistakes can lead to opening DoS or spam
            // attack vectors. See validation logic docs for more details.
            let _ = T::SubmitUnsignedTransaction::submit_unsigned(call)
                .map_err(|()| "Unable to submit unsigned transaction.")?;
        }
        Ok(())
    }

    fn is_unsigned_transaction_allowed(block_number: T::BlockNumber) -> bool {
        // check whether the last extrinsic submission blockNumber + cooling interval should be
        // greater than current block number or not.
        // It is not recommended to hook unsigned txn in every block because it is a non-deterministic
        // task we are not sure how much time it will take to process. So cooling period is recommended
        // to provide the gap for the execution of non-deterministic task.
        Self::last_extrinsic_submitted_at() + T::CoolingInterval::get() < block_number
    }
}

impl<T: Trait> frame_support::unsigned::ValidateUnsigned for Module<T> {
    type Call = Call<T>;

    /// Validate unsigned call to this module.
    ///
    /// By default unsigned transactions are disallowed, but implementing the validator
    /// here we make sure that some particular calls (the ones produced by offchain worker)
    /// are being exempted and marked as valid.
    fn validate_unsigned(call: &Self::Call) -> TransactionValidity {
        // Firstly let's check that we call the right function.
        if let Call::take_off_invalidate_nominators(block_number, target, signature) = call {
            // Now let's check if the transaction has any chance to succeed.
            let last_unsigned_at = <LastExtSubmittedAt<T>>::get();
            ensure!(
                last_unsigned_at + T::CoolingInterval::get() <= *block_number,
                InvalidTransaction::Stale
            );

            // Let's make sure to reject transactions from the future.
            ensure!(
                &<system::Module<T>>::block_number() >= block_number,
                InvalidTransaction::Future
            );

            // Get the key from the store to verify whether the signed signature is
            // generated from the validator or not.
            let signer_id = T::SignerId::all()
                .into_iter()
                .next()
                .ok_or(InvalidTransaction::BadProof)?;

            let signature_valid = target.using_encoded(|encoded_nominators| {
                signer_id.verify(&encoded_nominators, &signature)
            });
            // validating signature
            ensure!(signature_valid, InvalidTransaction::BadProof);

            Ok(ValidTransaction {
                // We set the priority to the max value - 10000. ~ near to high priority
                // TODO: We can change after discussion
                priority: TransactionPriority::max_value() - 10000_u64,
                requires: vec![],
                // We set the `provides` tag to be the same as `last_unsigned_at`. This makes
                // sure only one transaction produced after `last_unsigned_at` will ever
                // get to the transaction pool and will end up in the block.
                // We can still have multiple transactions compete for the same "spot",
                // and the one with higher priority will replace other one in the pool.
                provides: vec![codec::Encode::encode(&(KEY_TYPE.0, last_unsigned_at))],
                // The transaction is only valid for next n blocks. After that it's
                // going to be revalidated by the pool. n = cooling interval
                longevity: (T::CoolingInterval::get()).saturated_into::<u64>(),
                propagate: true,
            })
        } else {
            InvalidTransaction::Call.into()
        }
    }
}
